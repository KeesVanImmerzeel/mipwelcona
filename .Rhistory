x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) %>% dplyr::mutate(TIME=TIME*365))
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) %>% dplyr::mutate(TIME=TIME*365))
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) )
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) )
x$TIME <- X$TIME * 365
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) )
x$TIME <- x$TIME * 365
return(x)
}
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>% dplyr::transmute(TIME=365*TIME)
#x$TIME <- x$TIME * 365
return(x)
}
strm_lns <- mw_read_streamlines(fname)
head(strm_lns)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>% dplyr::ungroup() %>% dplyr::transmute(TIME=365*TIME)
return(x)
}
strm_lns <- mw_read_streamlines(fname)
head(strm_lns)
?dplyr::transmute
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>%
dplyr::transmute(TIME=365*TIME, .keep = c("all"))
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>%
dplyr::transmute(TIME=365*TIME, .keep = "all")
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>% dplyr::ungroup() %>%
dplyr::transmute(TIME=365*TIME, .keep = "all")
return(x)
}
strm_lns <- mw_read_streamlines(fname)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>% dplyr::ungroup() %>%
dplyr::mutate(TIME=365*TIME)
return(x)
}
strm_lns <- mw_read_streamlines(fname)
head(strm_lns)
mw_read_streamlines <- function(fname) {
# On a streamline : calculate the distance to previous point.
.f <- function(data,...) {
data %>% dplyr::mutate(DIST = sqrt( (dplyr::lag(X, default=X[1]) - X) ^ 2 +
(dplyr::lag(Y, default=Y[1]) - Y) ^ 2 +
(dplyr::lag(Z, default=Z[1]) - Z) ^ 2) )
}
n <-
readLines(fname, n = 1) %>% as.numeric()
x <- readLines(fname, n = n + 1)
x <- x[2:length(x)]
i <-
c(
which(x == "PARTICLE_NUMBER"),
which(x == "ILAY"),
which(x == "XCRD."),
which(x == "YCRD."),
which(x == "ZCRD."),
which(x == "TIME(YEARS)")
)
if (length(i) != 6) {
stop("Not all information is included in iff-file.")
}
x <-
utils::read.csv(
fname,
header = FALSE,
sep = "",
dec = ".",
fill = FALSE,
skip = n + 1
)
x <- x[, i]
names(x) <- c("SL_NR", "LAY", "X", "Y", "Z", "TIME")
# Double records are filtered out; group by streamline (SL_NR); add
x %<>% dplyr::select("X", "Y", "Z", "TIME", "LAY", "SL_NR") %>%
dplyr::distinct(X, Y, Z, TIME, .keep_all = TRUE) %>% dplyr::group_by(SL_NR) %>%
dplyr::group_modify(.f) %>% dplyr::mutate(DIST = cumsum(DIST) ) %>%
dplyr::mutate(TIME=365*TIME)
return(x)
}
strm_lns <- mw_read_streamlines(fname)
head(strm_lns)
fname <-
system.file("extdata", "streamlines.iff", package = "mipwelcona")
chk_mw_read_streamlines <- mw_read_streamlines(fname)
fname <-
system.file("extdata", "well_filters.ipf", package = "mipwelcona")
chk_mw_read_well_filters <- mw_read_well_filters(fname)
chk_sl_fltr_table <- .mw_create_sl_fltr_table(chk_mw_read_streamlines, chk_mw_read_well_filters)
## Save internal objects
usethis::use_data(chk_mw_read_streamlines,
chk_mw_read_well_filters,
chk_sl_fltr_table,
overwrite = TRUE,
internal = TRUE)
document()
library(devtools)
load_all()
document()
